package com.amazon.ion.benchmark;

import com.amazon.ion.IonType;
import java.util.Map;

public class GeneratorOptions {
    /**
     * Call the relevant methods which can generate scalar type of Ion data based on the input hashmap.
     * @param optionsMap is the hash map which generated by the command line parser which match the option name and its value appropriately.
     * @throws Exception if errors occurs when calling the methods of generating Ion data.
     */
    public static void executeGenerator(Map<String, Object> optionsMap) throws Exception {
        int size = Integer.parseInt(optionsMap.get("--data-size").toString());
        String expRange = optionsMap.get("--decimal-exponent-range").toString();
        String coefficientDigits = optionsMap.get("--decimal-coefficient-digit-range").toString();
        String format = optionsMap.get("--format").toString().substring(1, optionsMap.get("--format").toString().length() - 1);
        String path = optionsMap.get("<output_file>").toString();
        String range = optionsMap.get("--text-code-point-range").toString();
        String type = optionsMap.get("--data-type").toString();
        Object timestampTemplate = optionsMap.get("--timestamps-template");
        Object inputFile = optionsMap.get("--input-Ion-Schema");

        if (inputFile != null) {
            writeDataBasedOnIonSchema.read(inputFile.toString());
        }

        switch (IonType.valueOf(type.toUpperCase())) {
            case TIMESTAMP:
                WriteRandomIonValues.writeRandomTimestamps(size, path, timestampTemplate, format);
                break;
            case STRING:
                WriteRandomIonValues.writeRandomStrings(size, path, range, format);
                break;
            case DECIMAL:

                WriteRandomIonValues.writeRandomDecimals(size, path, format, expRange, coefficientDigits);
                break;
            case INT:
                WriteRandomIonValues.writeRandomInts(size, format, path);
                break;
            case FLOAT:
                WriteRandomIonValues.writeRandomFloats(size, format, path);
                break;
            case BLOB:
                WriteRandomIonValues.writeRandomLobs(size, type, format, path);
                break;
            case CLOB:
                WriteRandomIonValues.writeRandomLobs(size, type, format, path);
                break;
            case SYMBOL:
                WriteRandomIonValues.writeRandomSymbolValues(size, format, path);
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + type);
        }
    }
}
